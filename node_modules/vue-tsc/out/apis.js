"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = void 0;
const lsTypes = ['script', 'template'];
function register(ts, context) {
    return {
        getRootFileNames,
        emit,
        getSyntacticDiagnostics,
        getSemanticDiagnostics,
        getGlobalDiagnostics,
        getBindAndCheckDiagnostics,
    };
    function getRootFileNames() {
        const set = new Set([
            ...getProgram('script')?.getRootFileNames().filter(fileName => context.getTsLsHost('script').fileExists?.(fileName)) ?? [],
            ...getProgram('template')?.getRootFileNames().filter(fileName => context.getTsLsHost('template')?.fileExists?.(fileName)) ?? [],
        ]);
        return [...set.values()];
    }
    // for vue-tsc --noEmit --watch
    function getBindAndCheckDiagnostics(sourceFile, cancellationToken) {
        return getSourceFileDiagnosticsWorker(sourceFile, cancellationToken, 'getBindAndCheckDiagnostics');
    }
    // for vue-tsc --noEmit
    function getSyntacticDiagnostics(sourceFile, cancellationToken) {
        return getSourceFileDiagnosticsWorker(sourceFile, cancellationToken, 'getSyntacticDiagnostics');
    }
    function getSemanticDiagnostics(sourceFile, cancellationToken) {
        return getSourceFileDiagnosticsWorker(sourceFile, cancellationToken, 'getSemanticDiagnostics');
    }
    function getSourceFileDiagnosticsWorker(sourceFile, cancellationToken, api) {
        if (sourceFile) {
            const mapped = context.vueFiles.fromEmbeddedFileName('script', sourceFile.fileName);
            if (mapped) {
                let results = [];
                const embeddeds = mapped.vueFile.getAllEmbeddeds();
                for (const embedded of embeddeds) {
                    if (embedded.file.lsType === 'nonTs' || !embedded.file.capabilities.diagnostics)
                        continue;
                    const program = getProgram(embedded.file.lsType);
                    const embeddedSourceFile = program?.getSourceFile(embedded.file.fileName);
                    if (embeddedSourceFile) {
                        const errors = transformDiagnostics(embedded.file.lsType, program?.[api](embeddedSourceFile, cancellationToken) ?? []);
                        results = results.concat(errors);
                    }
                }
                return results;
            }
            else {
                return getProgram('script')?.[api](sourceFile, cancellationToken) ?? [];
            }
        }
        return lsTypes.map(lsType => transformDiagnostics(lsType, getProgram(lsType)?.[api](sourceFile, cancellationToken) ?? [])).flat();
    }
    function getGlobalDiagnostics(cancellationToken) {
        return lsTypes.map(lsType => transformDiagnostics(lsType, getProgram(lsType)?.getGlobalDiagnostics(cancellationToken) ?? [])).flat();
    }
    function emit(targetSourceFile, _writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers) {
        const scriptResult = getProgram('script').emit(targetSourceFile, (context.vueLsHost.writeFile ?? ts.sys.writeFile), cancellationToken, emitOnlyDtsFiles, customTransformers);
        const templateResult = getProgram('template')?.emit(targetSourceFile, undefined, cancellationToken, emitOnlyDtsFiles, customTransformers);
        return {
            emitSkipped: scriptResult.emitSkipped,
            emittedFiles: scriptResult.emittedFiles,
            diagnostics: [
                ...transformDiagnostics('script', scriptResult.diagnostics),
                ...transformDiagnostics('template', templateResult?.diagnostics ?? []),
            ],
        };
    }
    function getProgram(lsType) {
        return context.getTsLs(lsType)?.getProgram();
    }
    // transform
    function transformDiagnostics(lsType, diagnostics) {
        const result = [];
        for (const diagnostic of diagnostics) {
            if (diagnostic.file !== undefined
                && diagnostic.start !== undefined
                && diagnostic.length !== undefined) {
                for (const tsOrVueLoc of context.vueFiles.fromEmbeddedLocation(lsType, diagnostic.file.fileName, diagnostic.start, diagnostic.start + diagnostic.length, data => !!data.capabilities.diagnostic)) {
                    if (!context.vueLsHost.fileExists?.(tsOrVueLoc.fileName))
                        continue;
                    if (!tsOrVueLoc.mapped && lsType !== 'script')
                        continue;
                    let file = tsOrVueLoc.fileName === diagnostic.file.fileName
                        ? diagnostic.file
                        : undefined;
                    if (!file) {
                        let docText = tsOrVueLoc.mapped?.vueFile.getContent();
                        if (docText === undefined) {
                            const snapshot = context.vueLsHost.getScriptSnapshot(tsOrVueLoc.fileName);
                            if (snapshot) {
                                docText = snapshot.getText(0, snapshot.getLength());
                            }
                        }
                        else {
                            file = ts.createSourceFile(tsOrVueLoc.fileName, docText, tsOrVueLoc.fileName.endsWith('.vue') ? ts.ScriptTarget.JSON : ts.ScriptTarget.Latest);
                        }
                    }
                    const newDiagnostic = {
                        ...diagnostic,
                        file,
                        start: tsOrVueLoc.range.start,
                        length: tsOrVueLoc.range.end - tsOrVueLoc.range.start,
                    };
                    const relatedInformation = diagnostic.relatedInformation;
                    if (relatedInformation) {
                        newDiagnostic.relatedInformation = transformDiagnostics(lsType, relatedInformation);
                    }
                    result.push(newDiagnostic);
                }
            }
            else if (diagnostic.file === undefined) {
                result.push(diagnostic);
            }
        }
        return result;
    }
}
exports.register = register;
//# sourceMappingURL=apis.js.map