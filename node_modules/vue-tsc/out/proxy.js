"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createProgramProxy = void 0;
const ts = require("typescript/lib/tsserverlibrary");
const apis = require("./apis");
const vue_typescript_1 = require("@volar/vue-typescript");
const vue_typescript_2 = require("@volar/vue-typescript");
let projectVersion = 0;
function createProgramProxy(options, // rootNamesOrOptions: readonly string[] | CreateProgramOptions,
_options, _host, _oldProgram, _configFileParsingDiagnostics) {
    if (!options.options.noEmit && !options.options.emitDeclarationOnly)
        return doThrow('js emit is not support');
    if (!options.host)
        return doThrow('!options.host');
    projectVersion++;
    const host = options.host;
    const vueCompilerOptions = getVueCompilerOptions();
    const scripts = new Map();
    const vueLsHost = {
        ...host,
        resolveModuleNames: undefined,
        writeFile: undefined,
        getCompilationSettings: () => options.options,
        getVueCompilationSettings: () => vueCompilerOptions,
        getScriptFileNames: () => {
            return options.rootNames;
        },
        getScriptVersion,
        getScriptSnapshot,
        getProjectVersion: () => {
            return projectVersion.toString();
        },
        getVueProjectVersion: () => {
            return projectVersion.toString();
        },
        getProjectReferences: () => options.projectReferences,
    };
    const tsRuntime = options.oldProgram?.__VLS_tsRuntime ?? (0, vue_typescript_1.createTypeScriptRuntime)({
        typescript: ts,
        baseCssModuleType: 'any',
        getCssClasses: () => ({}),
        vueCompilerOptions,
        vueLsHost: vueLsHost,
        isVueTsc: true,
    });
    tsRuntime.update(true); // must update before getProgram() to update virtual scripts
    const tsProgram = tsRuntime.getTsLs('script').getProgram();
    if (!tsProgram)
        throw '!tsProgram';
    const proxyApis = apis.register(ts, tsRuntime);
    const program = new Proxy(tsProgram, {
        get: (target, property) => {
            tsRuntime.update(true);
            return proxyApis[property] || target[property];
        },
    });
    program.__VLS_tsRuntime = tsRuntime;
    for (const rootName of options.rootNames) {
        // register file watchers
        host.getSourceFile(rootName, ts.ScriptTarget.ESNext);
    }
    return program;
    function getVueCompilerOptions() {
        const tsConfig = options.options.configFilePath;
        if (typeof tsConfig === 'string') {
            return vue_typescript_2.tsShared.createParsedCommandLine(ts, ts.sys, tsConfig).vueOptions;
        }
        return {};
    }
    function getScriptVersion(fileName) {
        return getScript(fileName)?.version ?? '';
    }
    function getScriptSnapshot(fileName) {
        return getScript(fileName)?.scriptSnapshot;
    }
    function getScript(fileName) {
        const script = scripts.get(fileName);
        if (script?.projectVersion === projectVersion) {
            return script;
        }
        const modifiedTime = ts.sys.getModifiedTime?.(fileName)?.valueOf() ?? 0;
        if (script?.modifiedTime === modifiedTime) {
            return script;
        }
        if (host.fileExists(fileName)) {
            const fileContent = host.readFile(fileName);
            if (fileContent !== undefined) {
                const script = {
                    projectVersion,
                    modifiedTime,
                    scriptSnapshot: ts.ScriptSnapshot.fromString(fileContent),
                    version: host.createHash?.(fileContent) ?? fileContent,
                };
                scripts.set(fileName, script);
                return script;
            }
        }
    }
}
exports.createProgramProxy = createProgramProxy;
function doThrow(msg) {
    console.error(msg);
    throw msg;
}
//# sourceMappingURL=proxy.js.map