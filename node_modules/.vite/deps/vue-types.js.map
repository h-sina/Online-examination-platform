{
  "version": 3,
  "sources": ["dep:vue-types", "../../is-plain-object/dist/is-plain-object.mjs", "../../vue-types/src/config.ts", "../../vue-types/src/utils.ts", "../../vue-types/src/validators/native.ts", "../../vue-types/src/validators/custom.ts", "../../vue-types/src/validators/oneof.ts", "../../vue-types/src/validators/oneoftype.ts", "../../vue-types/src/validators/arrayof.ts", "../../vue-types/src/validators/instanceof.ts", "../../vue-types/src/validators/objectof.ts", "../../vue-types/src/validators/shape.ts", "../../vue-types/src/index.ts", "../../vue-types/src/sensibles.ts"],
  "sourcesContent": ["import d from \"./node_modules/vue-types/dist/vue-types.modern.js\";export default d;\nexport * from \"./node_modules/vue-types/dist/vue-types.modern.js\"", "/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nfunction isObject(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (ctor === undefined) return true;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n}\n\nexport { isPlainObject };\n", "import { VueTypesConfig } from './types'\n\nexport const config: VueTypesConfig = {\n  silent: false,\n  logLevel: 'warn',\n}\n", "import { isPlainObject as _isPlainObject } from 'is-plain-object'\nimport { config } from './config'\nimport {\n  VueTypeDef,\n  VueTypeValidableDef,\n  VueProp,\n  InferType,\n  PropOptions,\n} from './types'\n\nconst ObjProto = Object.prototype\nconst toString = ObjProto.toString\nexport const hasOwn = ObjProto.hasOwnProperty\n\nconst FN_MATCH_REGEXP = /^\\s*function (\\w+)/\n\n// https://github.com/vuejs/vue/blob/dev/src/core/util/props.js#L177\nexport function getType(\n  fn: VueProp<any> | (() => any) | (new (...args: any[]) => any),\n): string {\n  const type = (fn as VueProp<any>)?.type ?? fn\n  if (type) {\n    const match = type.toString().match(FN_MATCH_REGEXP)\n    return match ? match[1] : ''\n  }\n  return ''\n}\n\nexport function getNativeType(value: any): string {\n  if (value === null || value === undefined) return ''\n  const match = value.constructor.toString().match(FN_MATCH_REGEXP)\n  return match ? match[1] : ''\n}\n\ntype PlainObject = { [key: string]: any }\nexport const isPlainObject = _isPlainObject as (obj: any) => obj is PlainObject\n\n/**\n * No-op function\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function noop() {}\n\n/**\n * A function that returns its first argument\n *\n * @param arg - Any argument\n */\nexport const identity = (arg: any) => arg\n\nlet warn: (msg: string) => string | void = identity\n\nif (process.env.NODE_ENV !== 'production') {\n  const hasConsole = typeof console !== 'undefined'\n  warn = hasConsole\n    ? function warn(msg: string, level = config.logLevel) {\n        if (config.silent === false) {\n          console[level](`[VueTypes warn]: ${msg}`)\n        }\n      }\n    : identity\n}\n\nexport { warn }\n\n/**\n * Checks for a own property in an object\n *\n * @param {object} obj - Object\n * @param {string} prop - Property to check\n */\nexport const has = <T, U extends keyof T>(obj: T, prop: U) =>\n  hasOwn.call(obj, prop)\n\n/**\n * Determines whether the passed value is an integer. Uses `Number.isInteger` if available\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\n * @param {*} value - The value to be tested for being an integer.\n * @returns {boolean}\n */\nexport const isInteger =\n  Number.isInteger ||\n  function isInteger(value: unknown): value is number {\n    return (\n      typeof value === 'number' &&\n      isFinite(value) &&\n      Math.floor(value) === value\n    )\n  }\n\n/**\n * Determines whether the passed value is an Array.\n *\n * @param {*} value - The value to be tested for being an array.\n * @returns {boolean}\n */\nexport const isArray =\n  Array.isArray ||\n  function isArray(value): value is any[] {\n    return toString.call(value) === '[object Array]'\n  }\n\n/**\n * Checks if a value is a function\n *\n * @param {any} value - Value to check\n * @returns {boolean}\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport const isFunction = <T extends Function>(value: unknown): value is T =>\n  toString.call(value) === '[object Function]'\n\n/**\n * Checks if the passed-in value is a VueTypes type\n * @param value - The value to check\n */\nexport const isVueTypeDef = <T>(\n  value: any,\n): value is VueTypeDef<T> | VueTypeValidableDef<T> =>\n  isPlainObject(value) && has(value, '_vueTypes_name')\n\n/**\n * Checks if the passed-in value is a Vue prop definition object or a VueTypes type\n * @param value - The value to check\n */\nexport const isComplexType = <T>(value: any): value is VueProp<T> =>\n  isPlainObject(value) &&\n  (has(value, 'type') ||\n    ['_vueTypes_name', 'validator', 'default', 'required'].some((k) =>\n      has(value, k),\n    ))\n\nexport interface WrappedFn {\n  (...args: any[]): any\n  __original: (...args: any[]) => any\n}\n\n/**\n * Binds a function to a context and saves a reference to the original.\n *\n * @param fn - Target function\n * @param ctx - New function context\n */\nexport function bindTo(fn: (...args: any[]) => any, ctx: any): WrappedFn {\n  return Object.defineProperty(fn.bind(ctx) as WrappedFn, '__original', {\n    value: fn,\n  })\n}\n\n/**\n * Returns the original function bounded with `bindTo`. If the passed-in function\n * has not be bound, the function itself will be returned instead.\n *\n * @param fn - Function to unwrap\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function unwrap<T extends WrappedFn | Function>(fn: T) {\n  return (fn as WrappedFn).__original ?? fn\n}\n\n/**\n * Validates a given value against a prop type object.\n *\n * If `silent` is `false` (default) will return a boolean. If it is set to `true`\n * it will return `true` on success or a string error message on failure\n *\n * @param {Object|*} type - Type to use for validation. Either a type object or a constructor\n * @param {*} value - Value to check\n * @param {boolean} silent - Silence warnings\n */\nexport function validateType<T, U>(\n  type: T,\n  value: U,\n  silent = false,\n): string | boolean {\n  let typeToCheck: { [key: string]: any }\n  let valid = true\n  let expectedType = ''\n  if (!isPlainObject(type)) {\n    typeToCheck = { type }\n  } else {\n    typeToCheck = type\n  }\n  const namePrefix = isVueTypeDef(typeToCheck)\n    ? typeToCheck._vueTypes_name + ' - '\n    : ''\n\n  if (isComplexType(typeToCheck) && typeToCheck.type !== null) {\n    if (typeToCheck.type === undefined || typeToCheck.type === true) {\n      return valid\n    }\n    if (!typeToCheck.required && value === undefined) {\n      return valid\n    }\n    if (isArray(typeToCheck.type)) {\n      valid = typeToCheck.type.some(\n        (type: any) => validateType(type, value, true) === true,\n      )\n      expectedType = typeToCheck.type\n        .map((type: any) => getType(type))\n        .join(' or ')\n    } else {\n      expectedType = getType(typeToCheck)\n\n      if (expectedType === 'Array') {\n        valid = isArray(value)\n      } else if (expectedType === 'Object') {\n        valid = isPlainObject(value)\n      } else if (\n        expectedType === 'String' ||\n        expectedType === 'Number' ||\n        expectedType === 'Boolean' ||\n        expectedType === 'Function'\n      ) {\n        valid = getNativeType(value) === expectedType\n      } else {\n        valid = value instanceof typeToCheck.type\n      }\n    }\n  }\n\n  if (!valid) {\n    const msg = `${namePrefix}value \"${value}\" should be of type \"${expectedType}\"`\n    if (silent === false) {\n      warn(msg)\n      return false\n    }\n    return msg\n  }\n\n  if (has(typeToCheck, 'validator') && isFunction(typeToCheck.validator)) {\n    const oldWarn = warn\n    const warnLog: string[] = []\n    warn = (msg) => {\n      warnLog.push(msg)\n    }\n\n    valid = typeToCheck.validator(value)\n    warn = oldWarn\n\n    if (!valid) {\n      const msg = (warnLog.length > 1 ? '* ' : '') + warnLog.join('\\n* ')\n      warnLog.length = 0\n      if (silent === false) {\n        warn(msg)\n        return valid\n      }\n      return msg\n    }\n  }\n  return valid\n}\n\n/**\n * Adds `isRequired` and `def` modifiers to an object\n *\n * @param {string} name - Type internal name\n * @param {object} obj - Object to enhance\n */\nexport function toType<T = any>(name: string, obj: PropOptions<T>) {\n  const type: VueTypeDef<T> = Object.defineProperties(obj as VueTypeDef<T>, {\n    _vueTypes_name: {\n      value: name,\n      writable: true,\n    },\n    isRequired: {\n      get() {\n        this.required = true\n        return this\n      },\n    },\n    def: {\n      value(def?: any) {\n        if (def === undefined) {\n          if (has(this, 'default')) {\n            delete this.default\n          }\n          return this\n        }\n        if (!isFunction(def) && validateType(this, def, true) !== true) {\n          warn(`${this._vueTypes_name} - invalid default value: \"${def}\"`)\n          return this\n        }\n        if (isArray(def)) {\n          this.default = () => [...def]\n        } else if (isPlainObject(def)) {\n          this.default = () => Object.assign({}, def)\n        } else {\n          this.default = def\n        }\n        return this\n      },\n    },\n  })\n\n  const { validator } = type\n  if (isFunction(validator)) {\n    type.validator = bindTo(validator, type)\n  }\n\n  return type\n}\n\n/**\n * Like `toType` but also adds the `validate()` method to the type object\n *\n * @param {string} name - Type internal name\n * @param {object} obj - Object to enhance\n */\nexport function toValidableType<T = any>(name: string, obj: PropOptions<T>) {\n  const type = toType<T>(name, obj)\n  return Object.defineProperty(type, 'validate', {\n    value(fn: (value: T) => boolean) {\n      if (isFunction(this.validator)) {\n        warn(\n          `${\n            this._vueTypes_name\n          } - calling .validate() will overwrite the current custom validator function. Validator info:\\n${JSON.stringify(\n            this,\n          )}`,\n        )\n      }\n      this.validator = bindTo(fn, this)\n      return this\n    },\n  }) as VueTypeValidableDef<T>\n}\n\n/**\n *  Clones an object preserving all of it's own keys.\n *\n * @param obj - Object to clone\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function clone<T extends object>(obj: T): T {\n  const descriptors = {} as { [P in keyof T]: any }\n  Object.getOwnPropertyNames(obj).forEach((key) => {\n    descriptors[key as keyof T] = Object.getOwnPropertyDescriptor(obj, key)\n  })\n  return Object.defineProperties({}, descriptors) as T\n}\n\n/**\n * Return a new VueTypes type using another type as base.\n *\n * Properties in the `props` object will overwrite those defined in the source one\n * expect for the `validator` function. In that case both functions will be executed in series.\n *\n * @param name - Name of the new type\n * @param source - Source type\n * @param props - Custom type properties\n */\nexport function fromType<T extends VueTypeDef<any>>(name: string, source: T): T\nexport function fromType<\n  T extends VueTypeDef<any>,\n  V extends PropOptions<InferType<T>>,\n>(name: string, source: T, props: V): Omit<T, keyof V> & V\nexport function fromType<\n  T extends VueTypeDef<any>,\n  V extends PropOptions<InferType<T>>,\n>(name: string, source: T, props?: V) {\n  // 1. create an exact copy of the source type\n  const copy = clone(source)\n\n  // 2. give it a new name\n  copy._vueTypes_name = name\n\n  if (!isPlainObject(props)) {\n    return copy\n  }\n  const { validator, ...rest } = props\n\n  // 3. compose the validator function\n  // with the one on the source (if present)\n  // and ensure it is bound to the copy\n  if (isFunction(validator)) {\n    let { validator: prevValidator } = copy\n\n    if (prevValidator) {\n      prevValidator = unwrap(prevValidator) as (_v: any) => boolean\n    }\n\n    copy.validator = bindTo(\n      prevValidator\n        ? function (this: T, value: any) {\n            return (\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              prevValidator!.call(this, value) && validator.call(this, value)\n            )\n          }\n        : validator,\n      copy,\n    )\n  }\n  // 4. overwrite the rest, if present\n  return Object.assign(copy, rest as V)\n}\n\nexport function indent(string: string) {\n  return string.replace(/^(?!\\s*$)/gm, '  ')\n}\n", "import { toType, toValidableType, isInteger } from '../utils'\nimport { PropType } from '../types'\n\nexport const any = <T = any>() => toValidableType<T>('any', {})\n\nexport const func = <T extends (...args: any[]) => any>() =>\n  toValidableType<T>('function', {\n    type: Function as PropType<T>,\n  })\n\nexport const bool = () =>\n  toValidableType('boolean', {\n    type: Boolean,\n  })\n\nexport const string = <T extends string = string>() =>\n  toValidableType<T>('string', {\n    type: String as unknown as PropType<T>,\n  })\n\nexport const number = <T extends number = number>() =>\n  toValidableType<T>('number', {\n    type: Number as unknown as PropType<T>,\n  })\n\nexport const array = <T>() =>\n  toValidableType<T[]>('array', {\n    type: Array,\n  })\n\nexport const object = <T extends { [key: string]: any }>() =>\n  toValidableType<T>('object', {\n    type: Object,\n  })\n\nexport const integer = <T extends number = number>() =>\n  toType<T>('integer', {\n    type: Number as unknown as PropType<T>,\n    validator(value) {\n      return isInteger(value)\n    },\n  })\n\nexport const symbol = () =>\n  toType<symbol>('symbol', {\n    validator(value) {\n      return typeof value === 'symbol'\n    },\n  })\n", "import { toType, warn } from '../utils'\nimport { ValidatorFunction, VueTypeDef, PropType } from '../types'\n\nexport default function custom<T>(\n  validatorFn: ValidatorFunction<T>,\n  warnMsg = 'custom validation failed',\n) {\n  if (typeof validatorFn !== 'function') {\n    throw new TypeError(\n      '[VueTypes error]: You must provide a function as argument',\n    )\n  }\n\n  return toType<T>(validatorFn.name || '<<anonymous function>>', {\n    type: null as unknown as PropType<T>,\n    validator(this: VueTypeDef<T>, value: T) {\n      const valid = validatorFn(value)\n      if (!valid) warn(`${this._vueTypes_name} - ${warnMsg}`)\n      return valid\n    },\n  })\n}\n", "import { Prop } from '../types'\nimport { toType, warn, isArray } from '../utils'\n\nexport default function oneOf<T extends readonly any[]>(arr: T) {\n  if (!isArray(arr)) {\n    throw new TypeError(\n      '[VueTypes error]: You must provide an array as argument.',\n    )\n  }\n  const msg = `oneOf - value should be one of \"${arr.join('\", \"')}\".`\n  const allowedTypes = arr.reduce((ret, v) => {\n    if (v !== null && v !== undefined) {\n      const constr = (v as any).constructor\n      ret.indexOf(constr) === -1 && ret.push(constr)\n    }\n    return ret\n  }, [] as Prop<T[number]>[])\n\n  return toType<T[number]>('oneOf', {\n    type: allowedTypes.length > 0 ? allowedTypes : undefined,\n    validator(value) {\n      const valid = arr.indexOf(value) !== -1\n      if (!valid) warn(msg)\n      return valid\n    },\n  })\n}\n", "import { Prop, VueProp, InferType, PropType } from '../types'\nimport {\n  isArray,\n  isComplexType,\n  isVueTypeDef,\n  isFunction,\n  toType,\n  validateType,\n  warn,\n  indent,\n} from '../utils'\n\nexport default function oneOfType<\n  D extends V,\n  U extends VueProp<any> | Prop<any> = any,\n  V = InferType<U>,\n>(arr: U[]) {\n  if (!isArray(arr)) {\n    throw new TypeError(\n      '[VueTypes error]: You must provide an array as argument',\n    )\n  }\n\n  let hasCustomValidators = false\n\n  let nativeChecks: Prop<V>[] = []\n\n  for (let i = 0; i < arr.length; i += 1) {\n    const type = arr[i]\n    if (isComplexType<V>(type)) {\n      if (\n        isVueTypeDef<V>(type) &&\n        type._vueTypes_name === 'oneOf' &&\n        type.type\n      ) {\n        nativeChecks = nativeChecks.concat(type.type as PropType<V>)\n        continue\n      }\n      if (isFunction(type.validator)) {\n        hasCustomValidators = true\n      }\n      if (type.type === true || !type.type) {\n        warn('oneOfType - invalid usage of \"true\" or \"null\" as types.')\n        continue\n      } else {\n        nativeChecks = nativeChecks.concat(type.type)\n      }\n    } else {\n      nativeChecks.push(type as Prop<V>)\n    }\n  }\n\n  // filter duplicates\n  nativeChecks = nativeChecks.filter((t, i) => nativeChecks.indexOf(t) === i)\n\n  const typeProp = nativeChecks.length > 0 ? nativeChecks : null\n\n  if (!hasCustomValidators) {\n    // we got just native objects (ie: Array, Object)\n    // delegate to Vue native prop check\n    return toType<D>('oneOfType', {\n      type: typeProp as unknown as PropType<D>,\n    })\n  }\n\n  return toType<D>('oneOfType', {\n    type: typeProp as unknown as PropType<D>,\n    validator(value) {\n      const err: string[] = []\n      const valid = arr.some((type) => {\n        const t =\n          isVueTypeDef(type) && type._vueTypes_name === 'oneOf'\n            ? type.type || null\n            : type\n        const res = validateType(t, value, true)\n        if (typeof res === 'string') {\n          err.push(res)\n        }\n        return res === true\n      })\n      if (!valid) {\n        warn(\n          `oneOfType - provided value does not match any of the ${\n            err.length\n          } passed-in validators:\\n${indent(err.join('\\n'))}`,\n        )\n      }\n\n      return valid\n    },\n  })\n}\n", "import { Prop, VueProp, InferType } from '../types'\nimport { toType, validateType, warn, indent } from '../utils'\n\nexport default function arrayOf<T extends VueProp<any> | Prop<any>>(type: T) {\n  return toType<InferType<T>[]>('arrayOf', {\n    type: Array,\n    validator(values: any[]) {\n      let vResult: string | boolean = ''\n      const valid = values.every((value) => {\n        vResult = validateType(type, value, true)\n        return vResult === true\n      })\n      if (!valid) {\n        warn(`arrayOf - value validation error:\\n${indent(vResult as string)}`)\n      }\n      return valid\n    },\n  })\n}\n", "import { toType } from '../utils'\nimport { Constructor } from '../types'\n\nexport default function instanceOf<C extends Constructor>(\n  instanceConstructor: C,\n) {\n  return toType<InstanceType<C>>('instanceOf', {\n    type: instanceConstructor,\n  })\n}\n", "import { Prop, VueProp, InferType } from '../types'\nimport { toType, validateType, warn, indent } from '../utils'\n\nexport default function objectOf<T extends VueProp<any> | Prop<any>>(type: T) {\n  return toType<{ [key: string]: InferType<T> }>('objectOf', {\n    type: Object,\n    validator(obj) {\n      let vResult: string | boolean = ''\n      const valid = Object.keys(obj).every((key) => {\n        vResult = validateType(type, obj[key], true)\n        return vResult === true\n      })\n\n      if (!valid) {\n        warn(`objectOf - value validation error:\\n${indent(vResult as string)}`)\n      }\n      return valid\n    },\n  })\n}\n", "import { Prop, VueProp, VueTypeShape, VueTypeLooseShape } from '../types'\nimport { toType, validateType, warn, isPlainObject, indent } from '../utils'\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport default function shape<T extends object>(obj: {\n  [K in keyof T]: Prop<T[K]> | VueProp<T[K]>\n}): VueTypeShape<T> {\n  const keys = Object.keys(obj)\n  const requiredKeys = keys.filter((key) => !!(obj as any)[key]?.required)\n\n  const type = toType('shape', {\n    type: Object,\n    validator(this: VueTypeShape<T> | VueTypeLooseShape<T>, value) {\n      if (!isPlainObject(value)) {\n        return false\n      }\n      const valueKeys = Object.keys(value)\n\n      // check for required keys (if any)\n      if (\n        requiredKeys.length > 0 &&\n        requiredKeys.some((req) => valueKeys.indexOf(req) === -1)\n      ) {\n        const missing = requiredKeys.filter(\n          (req) => valueKeys.indexOf(req) === -1,\n        )\n        if (missing.length === 1) {\n          warn(`shape - required property \"${missing[0]}\" is not defined.`)\n        } else {\n          warn(\n            `shape - required properties \"${missing.join(\n              '\", \"',\n            )}\" are not defined.`,\n          )\n        }\n\n        return false\n      }\n\n      return valueKeys.every((key) => {\n        if (keys.indexOf(key) === -1) {\n          if ((this as VueTypeLooseShape<T>)._vueTypes_isLoose === true)\n            return true\n          warn(\n            `shape - shape definition does not include a \"${key}\" property. Allowed keys: \"${keys.join(\n              '\", \"',\n            )}\".`,\n          )\n          return false\n        }\n        const type = (obj as any)[key]\n        const valid = validateType(type, value[key], true)\n        if (typeof valid === 'string') {\n          warn(`shape - \"${key}\" property validation error:\\n ${indent(valid)}`)\n        }\n        return valid === true\n      })\n    },\n  }) as VueTypeShape<T>\n\n  Object.defineProperty(type, '_vueTypes_isLoose', {\n    writable: true,\n    value: false,\n  })\n\n  Object.defineProperty(type, 'loose', {\n    get() {\n      this._vueTypes_isLoose = true\n      return this\n    },\n  })\n\n  return type\n}\n", "import {\n  toType,\n  toValidableType,\n  validateType,\n  isArray,\n  isVueTypeDef,\n  has,\n  fromType,\n} from './utils'\n\nimport {\n  VueTypesDefaults,\n  ExtendProps,\n  VueTypeDef,\n  VueTypeValidableDef,\n  VueTypeShape,\n  VueTypeLooseShape,\n} from './types'\nimport { typeDefaults } from './sensibles'\nimport { PropOptions } from './types'\n\nimport {\n  any,\n  func,\n  bool,\n  string,\n  number,\n  array,\n  integer,\n  symbol,\n  object,\n} from './validators/native'\nimport custom from './validators/custom'\nimport oneOf from './validators/oneof'\nimport oneOfType from './validators/oneoftype'\nimport arrayOf from './validators/arrayof'\nimport instanceOf from './validators/instanceof'\nimport objectOf from './validators/objectof'\nimport shape from './validators/shape'\nimport { config } from './config'\n\nconst BaseVueTypes = /*#__PURE__*/ (() =>\n  class BaseVueTypes {\n    static defaults: Partial<VueTypesDefaults> = {}\n\n    static sensibleDefaults: Partial<VueTypesDefaults> | boolean\n\n    static config = config\n\n    static get any() {\n      return any()\n    }\n    static get func() {\n      return func().def(this.defaults.func)\n    }\n    static get bool() {\n      return bool().def(this.defaults.bool)\n    }\n    static get string() {\n      return string().def(this.defaults.string)\n    }\n    static get number() {\n      return number().def(this.defaults.number)\n    }\n    static get array() {\n      return array().def(this.defaults.array)\n    }\n    static get object() {\n      return object().def(this.defaults.object)\n    }\n    static get integer() {\n      return integer().def(this.defaults.integer)\n    }\n    static get symbol() {\n      return symbol()\n    }\n\n    static readonly custom = custom\n    static readonly oneOf = oneOf\n    static readonly instanceOf = instanceOf\n    static readonly oneOfType = oneOfType\n    static readonly arrayOf = arrayOf\n    static readonly objectOf = objectOf\n    static readonly shape = shape\n\n    static extend<T extends typeof BaseVueTypes>(\n      props: ExtendProps | ExtendProps[],\n    ): T {\n      if (isArray(props)) {\n        props.forEach((p) => this.extend(p))\n        return this as any\n      }\n\n      const { name, validate = false, getter = false, ...opts } = props\n\n      if (has(this, name as any)) {\n        throw new TypeError(`[VueTypes error]: Type \"${name}\" already defined`)\n      }\n\n      const { type } = opts\n      if (isVueTypeDef(type)) {\n        // we are using as base type a vue-type object\n\n        // detach the original type\n        // we are going to inherit the parent data.\n        delete opts.type\n\n        if (getter) {\n          return Object.defineProperty(this as T, name, {\n            get: () => fromType(name, type, opts as Omit<ExtendProps, 'type'>),\n          })\n        }\n        return Object.defineProperty(this as T, name, {\n          value(...args: unknown[]) {\n            const t = fromType(name, type, opts as Omit<ExtendProps, 'type'>)\n            if (t.validator) {\n              t.validator = t.validator.bind(t, ...args)\n            }\n            return t\n          },\n        })\n      }\n\n      let descriptor: PropertyDescriptor\n      if (getter) {\n        descriptor = {\n          get() {\n            const typeOptions = Object.assign({}, opts as PropOptions<T>)\n            if (validate) {\n              return toValidableType<T>(name, typeOptions)\n            }\n            return toType<T>(name, typeOptions)\n          },\n          enumerable: true,\n        }\n      } else {\n        descriptor = {\n          value(...args: T[]) {\n            const typeOptions = Object.assign({}, opts as PropOptions<T>)\n            let ret: VueTypeDef<T>\n            if (validate) {\n              ret = toValidableType<T>(name, typeOptions)\n            } else {\n              ret = toType<T>(name, typeOptions)\n            }\n\n            if (typeOptions.validator) {\n              ret.validator = typeOptions.validator.bind(ret, ...args)\n            }\n            return ret\n          },\n          enumerable: true,\n        }\n      }\n\n      return Object.defineProperty(this as T, name, descriptor)\n    }\n\n    static utils = {\n      validate<T, U>(value: T, type: U) {\n        return validateType<U, T>(type, value, true) === true\n      },\n      toType<T = unknown>(\n        name: string,\n        obj: PropOptions<T>,\n        validable = false,\n      ): VueTypeDef<T> | VueTypeValidableDef<T> {\n        return validable ? toValidableType<T>(name, obj) : toType<T>(name, obj)\n      },\n    }\n  })()\n\nfunction createTypes(defs: Partial<VueTypesDefaults> = typeDefaults()) {\n  return class extends BaseVueTypes {\n    static defaults: Partial<VueTypesDefaults> = { ...defs }\n\n    static get sensibleDefaults() {\n      return { ...this.defaults }\n    }\n\n    static set sensibleDefaults(v: boolean | Partial<VueTypesDefaults>) {\n      if (v === false) {\n        this.defaults = {}\n        return\n      }\n      if (v === true) {\n        this.defaults = { ...defs }\n        return\n      }\n      this.defaults = { ...v }\n    }\n  }\n}\n\nexport default class VueTypes /*#__PURE__*/ extends createTypes() {}\n\nexport {\n  any,\n  func,\n  bool,\n  string,\n  number,\n  array,\n  integer,\n  symbol,\n  object,\n  custom,\n  oneOf,\n  oneOfType,\n  arrayOf,\n  instanceOf,\n  objectOf,\n  shape,\n  createTypes,\n  toType,\n  toValidableType,\n  validateType,\n  fromType,\n  config,\n}\n\nexport type VueTypesInterface = ReturnType<typeof createTypes>\nexport type { VueTypeDef, VueTypeValidableDef, VueTypeShape, VueTypeLooseShape }\n", "import { VueTypesDefaults } from './types'\n\nexport const typeDefaults = (): VueTypesDefaults => ({\n  func: () => undefined,\n  bool: true,\n  string: '',\n  number: 0,\n  array: () => [],\n  object: () => ({}),\n  integer: 0,\n})\n"],
  "mappings": "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",
  "names": []
}
