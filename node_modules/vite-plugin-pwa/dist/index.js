var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// src/index.ts
__export(exports, {
  VitePWA: () => VitePWA,
  cachePreset: () => cachePreset
});
var import_path6 = __toModule(require("path"));
var import_fs5 = __toModule(require("fs"));

// src/constants.ts
var FILE_MANIFEST = "manifest.webmanifest";
var FILE_SW_REGISTER = "registerSW.js";
var VIRTUAL_MODULES_MAP = {
  "virtual:pwa-register": "register",
  "virtual:pwa-register/vue": "vue",
  "virtual:pwa-register/svelte": "svelte",
  "virtual:pwa-register/react": "react",
  "virtual:pwa-register/preact": "preact",
  "virtual:pwa-register/solid": "solid"
};
var VIRTUAL_MODULES_RESOLVE_PREFIX = "/@vite-plugin-pwa/";
var VIRTUAL_MODULES = Object.keys(VIRTUAL_MODULES_MAP);

// src/html.ts
function generateSimpleSWRegister(options2) {
  return `
if('serviceWorker' in navigator) {
window.addEventListener('load', () => {
navigator.serviceWorker.register('${options2.base + options2.filename}', { scope: '${options2.scope}' })
})
}`.replace(/\n/g, "");
}
function injectServiceWorker(html, options2) {
  const crossorigin = options2.useCredentials ? ' crossorigin="use-credentials"' : "";
  const manifest = options2.manifest ? `<link rel="manifest" href="${options2.base + FILE_MANIFEST}"${crossorigin}>` : "";
  if (options2.injectRegister === "inline") {
    return html.replace("</head>", `${manifest}<script>${generateSimpleSWRegister(options2)}<\/script></head>`);
  }
  if (options2.injectRegister === "script") {
    return html.replace("</head>", `${manifest}<script src="${options2.base + FILE_SW_REGISTER}"><\/script></head>`);
  }
  return html.replace("</head>", `${manifest}</head>`);
}

// src/modules.ts
var import_path2 = __toModule(require("path"));
var import_fs = __toModule(require("fs"));
var import_workbox_build = __toModule(require("workbox-build"));

// src/log.ts
var import_path = __toModule(require("path"));

// node_modules/.pnpm/kolorist@1.5.0/node_modules/kolorist/dist/esm/index.mjs
var enabled = true;
var globalVar = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
var supportLevel = 0;
if (globalVar.process && globalVar.process.env && globalVar.process.stdout) {
  const { FORCE_COLOR, NODE_DISABLE_COLORS, TERM } = globalVar.process.env;
  if (NODE_DISABLE_COLORS || FORCE_COLOR === "0") {
    enabled = false;
  } else if (FORCE_COLOR === "1") {
    enabled = true;
  } else if (TERM === "dumb") {
    enabled = false;
  } else if ("CI" in globalVar.process.env && [
    "TRAVIS",
    "CIRCLECI",
    "APPVEYOR",
    "GITLAB_CI",
    "GITHUB_ACTIONS",
    "BUILDKITE",
    "DRONE"
  ].some((vendor) => vendor in globalVar.process.env)) {
    enabled = true;
  } else {
    enabled = process.stdout.isTTY;
  }
  if (enabled) {
    supportLevel = TERM && TERM.endsWith("-256color") ? 2 : 1;
  }
}
var options = {
  enabled,
  supportLevel
};
function kolorist(start, end, level = 1) {
  const open = `[${start}m`;
  const close = `[${end}m`;
  const regex = new RegExp(`\\x1b\\[${end}m`, "g");
  return (str) => {
    return options.enabled && options.supportLevel >= level ? open + ("" + str).replace(regex, open) + close : "" + str;
  };
}
var reset = kolorist(0, 0);
var bold = kolorist(1, 22);
var dim = kolorist(2, 22);
var italic = kolorist(3, 23);
var underline = kolorist(4, 24);
var inverse = kolorist(7, 27);
var hidden = kolorist(8, 28);
var strikethrough = kolorist(9, 29);
var black = kolorist(30, 39);
var red = kolorist(31, 39);
var green = kolorist(32, 39);
var yellow = kolorist(33, 39);
var blue = kolorist(34, 39);
var magenta = kolorist(35, 39);
var cyan = kolorist(36, 39);
var white = kolorist(97, 39);
var gray = kolorist(90, 39);
var lightGray = kolorist(37, 39);
var lightRed = kolorist(91, 39);
var lightGreen = kolorist(92, 39);
var lightYellow = kolorist(93, 39);
var lightBlue = kolorist(94, 39);
var lightMagenta = kolorist(95, 39);
var lightCyan = kolorist(96, 39);
var bgBlack = kolorist(40, 49);
var bgRed = kolorist(41, 49);
var bgGreen = kolorist(42, 49);
var bgYellow = kolorist(43, 49);
var bgBlue = kolorist(44, 49);
var bgMagenta = kolorist(45, 49);
var bgCyan = kolorist(46, 49);
var bgWhite = kolorist(107, 49);
var bgGray = kolorist(100, 49);
var bgLightRed = kolorist(101, 49);
var bgLightGreen = kolorist(102, 49);
var bgLightYellow = kolorist(103, 49);
var bgLightBlue = kolorist(104, 49);
var bgLightMagenta = kolorist(105, 49);
var bgLightCyan = kolorist(106, 49);
var bgLightGray = kolorist(47, 49);

// package.json
var version = "0.11.13";

// src/log.ts
function logWorkboxResult(strategy, buildResult, viteOptions) {
  const { root, logLevel = "info" } = viteOptions;
  if (logLevel === "silent")
    return;
  const { count, size, filePaths, warnings } = buildResult;
  if (logLevel === "info") {
    console.info([
      "",
      `${cyan(`PWA v${version}`)}`,
      `mode      ${magenta(strategy)}`,
      `precache  ${green(`${count} entries`)} ${dim(`(${(size / 1024).toFixed(2)} KiB)`)}`,
      "files generated",
      ...filePaths.map((p) => `  ${dim((0, import_path.relative)(root, p))}`)
    ].join("\n"));
  }
  warnings && warnings.length > 0 && console.warn(yellow([
    "warnings",
    ...warnings.map((w) => `  ${w}`),
    ""
  ].join("\n")));
}

// src/modules.ts
async function generateRegisterSW(options2, mode, source = "register") {
  const sw = options2.base + options2.filename;
  const scope = options2.scope;
  const content = await import_fs.promises.readFile((0, import_path2.resolve)(__dirname, `client/${mode}/${source}.mjs`), "utf-8");
  return content.replace("__SW__", sw).replace("__SCOPE__", scope).replace("__SW_AUTO_UPDATE__", `${options2.registerType === "autoUpdate"}`).replace("__TYPE__", `${options2.devOptions.enabled ? options2.devOptions.type : "classic"}`);
}
async function generateServiceWorker(options2, viteOptions) {
  const buildResult = await (0, import_workbox_build.generateSW)(options2.workbox);
  logWorkboxResult("generateSW", buildResult, viteOptions);
  return buildResult;
}
async function generateInjectManifest(options2, viteOptions) {
  const rollup = require("rollup");
  const includedPluginNames = [
    "alias",
    "vite:resolve",
    "vite:esbuild",
    "replace",
    "vite:define",
    "rollup-plugin-dynamic-import-variables",
    "vite:esbuild-transpile",
    "vite:terser"
  ];
  const plugins = viteOptions.plugins.filter((p) => includedPluginNames.includes(p.name));
  const bundle = await rollup.rollup({
    input: options2.swSrc,
    plugins
  });
  try {
    await bundle.write({
      format: "es",
      exports: "none",
      inlineDynamicImports: true,
      file: options2.injectManifest.swDest,
      sourcemap: viteOptions.build.sourcemap
    });
  } finally {
    await bundle.close();
  }
  const injectManifestOptions = __spreadProps(__spreadValues({}, options2.injectManifest), {
    swSrc: options2.injectManifest.swDest
  });
  const buildResult = await (0, import_workbox_build.injectManifest)(injectManifestOptions);
  logWorkboxResult("injectManifest", buildResult, viteOptions);
}

// src/options.ts
var import_fs3 = __toModule(require("fs"));
var import_path4 = __toModule(require("path"));

// src/assets.ts
var import_path3 = __toModule(require("path"));
var import_fs2 = __toModule(require("fs"));
var import_crypto = __toModule(require("crypto"));
var import_fast_glob = __toModule(require("fast-glob"));
function buildManifestEntry(publicDir, url) {
  return new Promise((resolve5, reject) => {
    const cHash = import_crypto.default.createHash("MD5");
    const stream = import_fs2.default.createReadStream((0, import_path3.resolve)(publicDir, url));
    stream.on("error", (err) => {
      reject(err);
    });
    stream.on("data", (chunk) => {
      cHash.update(chunk);
    });
    stream.on("end", () => {
      return resolve5({
        url,
        revision: `${cHash.digest("hex")}`
      });
    });
  });
}
function lookupAdditionalManifestEntries(useInjectManifest, injectManifest2, workbox) {
  return useInjectManifest ? injectManifest2.additionalManifestEntries || [] : workbox.additionalManifestEntries || [];
}
async function configureStaticAssets(resolvedVitePWAOptions, viteConfig) {
  const {
    manifest,
    strategies,
    injectManifest: injectManifest2,
    workbox,
    includeAssets,
    includeManifestIcons
  } = resolvedVitePWAOptions;
  const useInjectManifest = strategies === "injectManifest";
  const { publicDir } = viteConfig;
  const globs = [];
  const manifestEntries = lookupAdditionalManifestEntries(useInjectManifest, injectManifest2, workbox);
  if (includeAssets) {
    if (Array.isArray(includeAssets))
      globs.push(...includeAssets);
    else
      globs.push(includeAssets);
  }
  if (includeManifestIcons && manifest && manifest.icons) {
    const icons = manifest.icons;
    Object.keys(icons).forEach((key) => {
      const icon = icons[key];
      globs.push(icon.src);
    });
  }
  if (globs.length > 0) {
    let assets = await (0, import_fast_glob.default)(globs.map((g) => {
      return g.startsWith("/") ? g.substring(1) : g;
    }), {
      cwd: publicDir,
      onlyFiles: true,
      unique: true
    });
    if (manifestEntries.length > 0) {
      const included = manifestEntries.map((me) => {
        if (typeof me === "string")
          return me;
        else
          return me.url;
      });
      assets = assets.filter((a) => !included.includes(a));
    }
    const assetsEntries = await Promise.all(assets.map((a) => {
      return buildManifestEntry(publicDir, a);
    }));
    manifestEntries.push(...assetsEntries);
  }
  if (manifest) {
    const cHash = import_crypto.default.createHash("MD5");
    cHash.update(generateWebManifestFile(resolvedVitePWAOptions));
    manifestEntries.push({
      url: FILE_MANIFEST,
      revision: `${cHash.digest("hex")}`
    });
  }
  if (manifestEntries.length > 0) {
    if (useInjectManifest)
      injectManifest2.additionalManifestEntries = manifestEntries;
    else
      workbox.additionalManifestEntries = manifestEntries;
  }
}
function generateWebManifestFile(options2) {
  return `${JSON.stringify(options2.manifest, null, options2.minify ? 0 : 2)}
`;
}

// src/utils.ts
function resolveBathPath(base) {
  if (isAbsolute(base))
    return base;
  return !base.startsWith("/") && !base.startsWith("./") ? `/${base}` : base;
}
function isAbsolute(url) {
  return url.match(/^(?:[a-z]+:)?\/\//i);
}
function normalizePath(path) {
  return path.replace(/\\/g, "/");
}

// src/options.ts
function resolveSwPaths(injectManifest2, root, srcDir, outDir, filename) {
  const swSrc = (0, import_path4.resolve)(root, srcDir, filename);
  if (injectManifest2 && (0, import_path4.extname)(filename) === ".ts" && import_fs3.default.existsSync(swSrc)) {
    const useFilename = `${filename.substring(0, filename.lastIndexOf("."))}.js`;
    return {
      swSrc,
      swDest: (0, import_path4.resolve)(root, outDir, useFilename),
      useFilename
    };
  }
  return {
    swSrc,
    swDest: (0, import_path4.resolve)(root, outDir, filename)
  };
}
async function resolveOptions(options2, viteConfig) {
  var _a;
  const root = viteConfig.root;
  const pkg = import_fs3.default.existsSync("package.json") ? JSON.parse(import_fs3.default.readFileSync("package.json", "utf-8")) : {};
  const {
    mode = process["env"]["NODE_ENV"] || "production",
    srcDir = "public",
    outDir = viteConfig.build.outDir || "dist",
    injectRegister = "auto",
    registerType = "prompt",
    filename = "sw.js",
    strategies = "generateSW",
    minify = true,
    base = viteConfig.base,
    includeAssets = void 0,
    includeManifestIcons = true,
    useCredentials = false,
    disable = false,
    devOptions = { enabled: false, type: "classic" }
  } = options2;
  const basePath = resolveBathPath(base);
  const { swSrc, swDest, useFilename } = resolveSwPaths(strategies === "injectManifest", root, srcDir, outDir, filename);
  const outDirRoot = (0, import_path4.resolve)(root, outDir);
  const scope = options2.scope || basePath;
  const defaultWorkbox = {
    swDest,
    globDirectory: outDirRoot,
    offlineGoogleAnalytics: false,
    cleanupOutdatedCaches: true,
    dontCacheBustURLsMatching: /\.[a-f0-9]{8}\./,
    mode,
    navigateFallback: "index.html"
  };
  const defaultInjectManifest = {
    swSrc,
    swDest,
    globDirectory: outDirRoot,
    dontCacheBustURLsMatching: /\.[a-f0-9]{8}\./,
    injectionPoint: "self.__WB_MANIFEST"
  };
  const defaultManifest = {
    name: pkg.name,
    short_name: pkg.name,
    start_url: basePath,
    display: "standalone",
    background_color: "#ffffff",
    lang: "en",
    scope
  };
  const workbox = Object.assign({}, defaultWorkbox, options2.workbox || {});
  const manifest = typeof options2.manifest === "boolean" && !options2.manifest ? false : Object.assign({}, defaultManifest, options2.manifest || {});
  const injectManifest2 = Object.assign({}, defaultInjectManifest, options2.injectManifest || {});
  if ((injectRegister === "auto" || registerType == null) && registerType === "autoUpdate") {
    workbox.skipWaiting = true;
    workbox.clientsClaim = true;
  }
  if (strategies === "generateSW" && workbox.sourcemap === void 0) {
    const sourcemap = (_a = viteConfig.build) == null ? void 0 : _a.sourcemap;
    workbox.sourcemap = sourcemap === true || sourcemap === "inline" || sourcemap === "hidden";
  }
  if (devOptions.enabled && viteConfig.command === "serve") {
    if (strategies === "generateSW")
      devOptions.type = "classic";
  } else {
    devOptions.enabled = false;
    devOptions.type = "classic";
  }
  const resolvedVitePWAOptions = {
    base: basePath,
    mode,
    swSrc,
    swDest,
    srcDir,
    outDir,
    injectRegister,
    registerType,
    filename: useFilename || filename,
    strategies,
    workbox,
    manifest,
    useCredentials,
    injectManifest: injectManifest2,
    scope,
    minify,
    includeAssets,
    includeManifestIcons,
    disable,
    devOptions
  };
  await configureStaticAssets(resolvedVitePWAOptions, viteConfig);
  return resolvedVitePWAOptions;
}

// src/dev.ts
var import_path5 = __toModule(require("path"));
var import_fs4 = __toModule(require("fs"));
var swDevOptions = {
  swUrl: "dev-sw.js?dev-sw",
  swDevGenerated: false,
  workboxPaths: new Map()
};
function resolveDevId(id, options2) {
  if (!options2.disable && options2.devOptions.enabled && options2.strategies === "injectManifest") {
    const name = id.startsWith("/") ? id.slice(1) : id;
    return name === swDevOptions.swUrl || name === options2.injectManifest.swSrc ? options2.injectManifest.swSrc : void 0;
  }
  return void 0;
}
async function loadDev(id, options2, viteConfig) {
  if (!options2.disable && options2.devOptions.enabled) {
    if (options2.strategies === "injectManifest") {
      const swSrc = normalizePath(options2.injectManifest.swSrc);
      if (id === swSrc) {
        let content = await import_fs4.promises.readFile(options2.injectManifest.swSrc, "utf-8");
        const resolvedIP = options2.injectManifest.injectionPoint;
        if (resolvedIP) {
          const ip = new RegExp(resolvedIP, "g");
          const navigateFallback = options2.devOptions.navigateFallback;
          if (navigateFallback)
            content = content.replace(ip, `[{ url: '${navigateFallback}' }]`);
          else
            content = content.replace(ip, "[]");
        }
        return content;
      }
      return void 0;
    }
    if (id.endsWith(swDevOptions.swUrl)) {
      const globDirectory = (0, import_path5.resolve)(viteConfig.root, "dev-dist");
      const swDest = (0, import_path5.resolve)(globDirectory, "sw.js");
      if (!swDevOptions.swDevGenerated || !(0, import_fs4.existsSync)(swDest)) {
        const navigateFallback = options2.workbox.navigateFallback;
        const { filePaths } = await generateServiceWorker(Object.assign({}, options2, {
          workbox: __spreadProps(__spreadValues({}, options2.workbox), {
            runtimeCaching: options2.devOptions.disableRuntimeConfig ? void 0 : options2.workbox.runtimeCaching,
            additionalManifestEntries: navigateFallback ? [navigateFallback] : void 0,
            cleanupOutdatedCaches: true,
            globDirectory: globDirectory.replace(/\\/g, "/"),
            swDest: swDest.replace(/\\/g, "/")
          })
        }), viteConfig);
        filePaths.forEach((we) => {
          const name = (0, import_path5.basename)(we);
          if (name !== "sw.js")
            swDevOptions.workboxPaths.set(normalizePath(`${options2.base}${name}`), we);
        });
        swDevOptions.swDevGenerated = true;
      }
      return await import_fs4.promises.readFile(swDest, "utf-8");
    }
    if (swDevOptions.workboxPaths.has(id))
      return await import_fs4.promises.readFile(swDevOptions.workboxPaths.get(id), "utf-8");
  }
}

// src/cache.ts
var cachePreset = [
  {
    urlPattern: /^https:\/\/fonts\.(?:googleapis|gstatic)\.com\/.*/i,
    handler: "CacheFirst",
    options: {
      cacheName: "google-fonts",
      expiration: {
        maxEntries: 4,
        maxAgeSeconds: 365 * 24 * 60 * 60
      }
    }
  },
  {
    urlPattern: /\.(?:eot|otf|ttc|ttf|woff|woff2|font.css)$/i,
    handler: "StaleWhileRevalidate",
    options: {
      cacheName: "static-font-assets",
      expiration: {
        maxEntries: 4,
        maxAgeSeconds: 7 * 24 * 60 * 60
      }
    }
  },
  {
    urlPattern: /\.(?:jpg|jpeg|gif|png|svg|ico|webp)$/i,
    handler: "StaleWhileRevalidate",
    options: {
      cacheName: "static-image-assets",
      expiration: {
        maxEntries: 64,
        maxAgeSeconds: 24 * 60 * 60
      }
    }
  },
  {
    urlPattern: /\.(?:js)$/i,
    handler: "StaleWhileRevalidate",
    options: {
      cacheName: "static-js-assets",
      expiration: {
        maxEntries: 32,
        maxAgeSeconds: 24 * 60 * 60
      }
    }
  },
  {
    urlPattern: /\.(?:css|less)$/i,
    handler: "StaleWhileRevalidate",
    options: {
      cacheName: "static-style-assets",
      expiration: {
        maxEntries: 32,
        maxAgeSeconds: 24 * 60 * 60
      }
    }
  },
  {
    urlPattern: /\.(?:json|xml|csv)$/i,
    handler: "NetworkFirst",
    options: {
      cacheName: "static-data-assets",
      expiration: {
        maxEntries: 32,
        maxAgeSeconds: 24 * 60 * 60
      }
    }
  },
  {
    urlPattern: /\/api\/.*$/i,
    handler: "NetworkFirst",
    method: "GET",
    options: {
      cacheName: "apis",
      expiration: {
        maxEntries: 16,
        maxAgeSeconds: 24 * 60 * 60
      },
      networkTimeoutSeconds: 10
    }
  },
  {
    urlPattern: /.*/i,
    handler: "NetworkFirst",
    options: {
      cacheName: "others",
      expiration: {
        maxEntries: 32,
        maxAgeSeconds: 24 * 60 * 60
      },
      networkTimeoutSeconds: 10
    }
  }
];

// src/index.ts
function VitePWA(userOptions = {}) {
  let viteConfig;
  let options2;
  let useImportRegister = false;
  async function _generateSW() {
    if (options2.disable)
      return;
    if (options2.strategies === "injectManifest")
      await generateInjectManifest(options2, viteConfig);
    else
      await generateServiceWorker(options2, viteConfig);
  }
  function _generateBundle(bundle = {}) {
    if (options2.disable)
      return;
    if (options2.manifest) {
      bundle[FILE_MANIFEST] = {
        isAsset: true,
        type: "asset",
        name: void 0,
        source: generateWebManifestFile(options2),
        fileName: FILE_MANIFEST
      };
    }
    if (options2.injectRegister === "auto")
      options2.injectRegister = useImportRegister ? null : "script";
    if (options2.injectRegister === "script" && !(0, import_fs5.existsSync)((0, import_path6.resolve)(viteConfig.publicDir, FILE_SW_REGISTER))) {
      bundle[FILE_SW_REGISTER] = {
        isAsset: true,
        type: "asset",
        name: void 0,
        source: generateSimpleSWRegister(options2),
        fileName: FILE_SW_REGISTER
      };
    }
    return bundle;
  }
  return [
    {
      name: "vite-plugin-pwa",
      enforce: "post",
      apply: "build",
      async configResolved(config) {
        viteConfig = config;
        options2 = await resolveOptions(userOptions, viteConfig);
      },
      transformIndexHtml: {
        enforce: "post",
        transform(html) {
          return options2.disable ? html : injectServiceWorker(html, options2);
        }
      },
      generateBundle(_, bundle) {
        _generateBundle(bundle);
      },
      async closeBundle() {
        if (!viteConfig.build.ssr && !options2.disable)
          await _generateSW();
      },
      async buildEnd(error) {
        if (error)
          throw error;
      },
      api: {
        get disabled() {
          return options2.disable;
        },
        generateBundle: _generateBundle,
        generateSW: _generateSW,
        extendManifestEntries(fn) {
          if (options2.disable)
            return;
          const configField = options2.strategies === "generateSW" ? "workbox" : "injectManifest";
          const result = fn(options2[configField].additionalManifestEntries || []);
          if (result != null)
            options2[configField].additionalManifestEntries = result;
        }
      }
    },
    {
      name: "vite-plugin-pwa:virtual",
      async configResolved(config) {
        viteConfig = config;
        options2 = await resolveOptions(userOptions, viteConfig);
      },
      resolveId(id) {
        return VIRTUAL_MODULES.includes(id) ? VIRTUAL_MODULES_RESOLVE_PREFIX + id : void 0;
      },
      load(id) {
        if (id.startsWith(VIRTUAL_MODULES_RESOLVE_PREFIX))
          id = id.slice(VIRTUAL_MODULES_RESOLVE_PREFIX.length);
        else
          return;
        if (VIRTUAL_MODULES.includes(id)) {
          if (viteConfig.command === "serve" && options2.devOptions.enabled) {
            return generateRegisterSW(__spreadProps(__spreadValues({}, options2), { filename: swDevOptions.swUrl }), "build", VIRTUAL_MODULES_MAP[id]);
          } else {
            useImportRegister = true;
            return generateRegisterSW(options2, !options2.disable && viteConfig.command === "build" ? "build" : "dev", VIRTUAL_MODULES_MAP[id]);
          }
        }
      }
    },
    {
      name: "vite-plugin-pwa:dev-sw",
      apply: "serve",
      enforce: "pre",
      async configResolved(config) {
        viteConfig = config;
        options2 = await resolveOptions(userOptions, viteConfig);
      },
      resolveId(id) {
        return resolveDevId(id, options2);
      },
      async load(id) {
        return await loadDev(id, options2, viteConfig);
      }
    }
  ];
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  VitePWA,
  cachePreset
});
